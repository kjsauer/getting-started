# Getting Started with Code and Software Program Architecture, Design, and Philosophy Principles
Kenneth J. Sauer (@kjsauer on GitHub)

## Acronyms & Terms
Varname = Variable name

## Development Environments
Anaconda Python + Spyder + GitHub Desktop
MATLAB + GitHub Desktop
RStudio + GitHub Desktop

## String Inputs
Import all inputs as strings
Convert the data type only when needed
For example, for decimal truncation or use in numerical calculations (e.g., unit conversions)
Then convert back to string

## Rosetta Stone
Ideally every piece of code would have a data structure Rosetta Stone (RS)
Need cookie-cutter code to implement Rosetta Stone in standard way

## Functions
Functions and APIs are similar (receive inputs; send outputs)
Write functions to take inputs with SI units
Thereby not a question as to what the units are

## Software Design
Fundamentals: EXE + config.csv
EXE prompts user for path of config.csv
EXE needs to be able to find config.csv
config.csv has vertical columns like a database
config.csv can have multiple rows representing different sets of inputs
Design config.csv for SQL

## Good Practice
Unit tests
Rosetta Stones
config.csv files
.exe plus runtime files

## General Principles
Less is more.

99% planning (and perspiration); 1% execution (and more perspiration...and 0% genius throughout...)

## Starting a Project
Ideally work backwards
Start with end functionality
e.g., Some literal function like Box Plot
This will drive the necessary data structures
Make those data structures in Excel test data file
Implement in Python, MATLAB, R, etc.
If importing/exporting, target CSV database format

## See Functions Early On
Start by finding the function(s) you want
The function drives the data structure(s) aka data frame(s)

## GUI Question(s)
How to avoid messing up a series of user actions in a GUI?

## Concept
How does MS Outlook not mess up my email when I make a series of actions? e.g., Moving emails from one folder to another
Theory: Because it stores a time-ordered queue of every user action and gradually worked through the queue
Apply this concept (user action time series queue) in software (GUI) development

## Data Analysis
Work with clean example SQL or CSV databases when possible
Execute calculations in legible/readable code script (e.g., Python notebook)

## Programming Language Tests
Tests to run to familiarize with new software language:
Inf/0
NaN + NaN
5 + NaN
NaN/0

## Archive Projects
When you complete a project, zip all project files and save in project folder
Consider exporting .ipynb to .py as a secondary backup of the code

## File Types
Code
--.ipynb
Data
--.csv
--.xls
--.xlsx
Metadata
--.txt
--.yml
--.xml
--.json

## Lessons Learned
Use Microsoft Excel template instead of Python script; copy/paste data into it. You may also use Excel as a GUI.

## Repo Contents
Package ALL critical help documentation and ALL helpful getting started examples (unit tests) and ALL essential unit test data into the repos; yes, the repo will become large, but everything will be in ONE folder that can be easily transferred and booted up and will be ready to spin up & rock.

## Inputs Data and Metadata
Rule: Every input must be a config (or data) file. This way others can tweak the input config files and not the code. Write code so others can get started quickly. Provide unit test with software program, data, and metadata, and program help menu (if needed). Provide answers as well so the user knows if the program ran correctly.

## Empty Folder Template
Provide:
--_todo/Future Work/TODO
--Analysis Templates
--Code and Scripts
--Data
--Docs (incl. Help Menu)
--Lessons Learned
--Metadata
--Report Templates
--Unit Tests: Known inputs
--Unit Tests Results: Known outputs 
--Work Instructions

## _todo/TODO List
Always have a TODO List that is numbered.
1. [DONE] (hm) Make TODO list for home tasks.
2. [DONE] (wk) Make TODO list for work tasks.
3. (hm) Win the lottery, amass a fortune, and retire to an island getaway.
4. [DONE] Label aka tag items as Done when completed.

## Unit Test Exercise Philosophy
Unit test: Known inputs/known outputs
Purpose(s):
So that an engineer can know someone/something is properly trained.
So that you can ensure an updated tool yields the same results.

## File Naming
Short yet descriptive filenames are best. Bear in mind Indexing and Search: How will you search for and find the file?

## Matrix Indexing
MATLAB starts with 1.
Python starts with 0.
R starts with 1.

## General Computer Usage
Find ways to avoid using the mouse whenever possible.

## Work vs. Personal
Keep work projects separate from personal projects.
Same GitHub account is fine.
Work on different computers in different repos.
When engaging in industry for learning, etc., use personal email.
When representing a company in the engagement, use company email.

## Documentation
In all cases, package into one, single repository all of the necessary files required to reproduce an expected set of results (which is also contained in the repository). Consider this from the time of project onset.

## Standalone Application (EXE)
TODO: TBD

## Build Auto-Image Detection Tool
Build training GUI.
Have algorithm make guess via artificial intelligence (AI) and machine learning (ML).
Have operator (human) correct guess.
This new human data is incorporated into AI/ML algorithm to improve it.
Calculate % accuracy each time; it must improve up to some high value, e.g., >97.5% (ideally higher).

## Timestamps
Use format YYYY-MM-DD hh:mm:ss

## Output File(s) Storage
Save into pwd\Ouptuts_timestamp,
where timestamp is updated each time.
See MATLAB Getting Started for example.

## Software Design
EXE + CFG.txt -> GUI EXE
GUI includes text field for path to raw input data files.

## Software Design
Docs
--General Intro and Data Needs
--Work Instructions
Tool
---README
---EXE (launches GUI)
---CFG.txt (replaces GUI)

## Start w/ Empty Results Structure
Before doing any project, design the END product: The folder directory, the final results table, etc. Imagine the very end result (as far as you can go). Set up the empty architecture or template and then work towards populating it as fast as possible while skipping all the details (which usually end up being irrelevant anyway). A fully populated architecture (e.g., a folder with subfolders) can be zipped into one zip file that has everything needed for anyone to reproduce it at any later time as needed. This approach even goes for something like cooking a meal. Prepare the ingredients, dishes, condiments, etc. in advance. Fill and use them all as you go. (I'm not actually suggesting the latter; it's merely for the sake of metaphor).

## Working Directories
Maintain four (4) folders:
_dev Project --personal, not shared
Project Eng Dev --shared
Project Training --shared
Project Training Results --shared

## NREL Fancy Site File
Site information .csv self-produces a map of its own location. This cellular-genetic-like approach of embedding within something the ingredients and algorithm to make itself is quite appealing/compelling/interesting from a coding perspective (as with a biological organism), e.g., a code script that saves itself and everything it needs to produce a given set of results into a repository. If I recall correctly, I believe this general, philosophical concept relates to the PhD thesis of Stephen Wolfram (American-British computer scientist).

## Build Tools to Automate Existing Workflows
Build tools around workflows, not workflows around tools.
Credit not mine. Source: <https://news.ycombinator.com/item?id=24244329>
(I only read the headline, and I agree w/ it.)

## Software Design Adjectives
Design software to be simple, isolated, encapsulated, and modular.

## A Lobster's Advice
Don't marry your design after the first date. (NB: This likely applies to other aspects of life also!)
Source: <https://lobste.rs/s/rvuyep/don_t_marry_your_design_after_first_date/>

## Software Documentation Hand-off Requirements
1. Software program
2. Getting Started
3. Help Menu
4. Functional specification (description of inputs nad outputs)
5. Testing specification (unit aka regression test)
6. Theory guide
7. Practice guide

## Reason to Code (vs. Spreadsheets, etc.)
Code doesn't lie; intrinsically, it says what it does
Also, row limits of Excel (see Getting Started\Excel)
Best to leave OG data & data files untouched--import data into code & manipulate it as needed via code (again, code doesn't lie--reading it tells you exactly what you did w/ the data)
If needed, export it in the exact format needed for the next tool or part of the analysis or reporting process; ideally, this is directly used w/out any further manipulations needed

## Web App Design
Config (CFG) files into one format (e.g., .json).
Data files into another format (e.g., .csv).

## Handing off from Engineering to Operations (i.e., Going from "Development" to "Production")
One single, executable file (EXE) with a graphical user interface (GUI) is ideal for a user, technician, or operator.
(Actually, web-deployed applications are ideal.)
Cannot require manual modification of data files.
Modification of config files is O-K.
Config (CFG) files can be replaced by the GUI.

## Key Files for Handoff from Engineering to Operations (i.e., Going from "Development" to "Production")
Files needed for technician's/operator's machine:
1. Runtime and Runtime Update, if needed (e.g., MATLAB)
2. EXE of GUI (e.g., MATLAB, LabVIEW)
3. Downloaded data files of a given format and type in a given path.
4. Config CFG files in a given path.
The EXE generates an output folder in which to place output files.

## Design for EXE
An EXE can be run (called) w/ any language (e.g., Python, R, MATLAB, etc.).
e.g., Run EXE from Python:
$ run('C:\asdf1\asdf2.exe')

## Configuration Config CFG Files
Advantages of separate config file:
- Save inputs to preprocessor for future
- GUI replaces the need for CFG file

## Technical Debt
Most technical debt is B.S. It's true! Make a numbered TODO list (prioritized for urgent *** and highly urgent !!!), and it is probably <200 items. The top priority of those (highlighted w/ both *** and !!!) is probably ten items at most at any given time. Technical debt is manageable w/ a good to-do list.
<https://lobste.rs/s/1gzlyu/most_technical_debt_is_just_bullshit/>

## Backing Up
Worry about saving and properly archiving the End. Don't worry about saving the Means to the End. It helps to save the Means, but don't sweat losing it (sh!t happens). If you focus on properly saving and archiving the End, then hopefully you won't lose that and will thus avoid any associated, larger regrets.

## Dev vs. Production
Maintain a _dev environment (e.g., source code) that compiles/deploys into the production environment (e.g., compiled standalone EXE application).

## _dev Workflow
Start by gathering/collecting essential user inputs via CFG.txt file. Then add option for GUI. The CFG file forces the minimum viable set of inputs; it provides a nice, clean data specification.

## _todo aka TODO aka to-do
Maintain two "MAIN", numbered TODO lists: One for work (wk) and one for home (hm). You'll be surprised that all the items you think you have going on only boils down to roughly 300 simultaneous, concurrent projects at once (300 for work and 300 for home; come on, 600 simultaneous projects ongoing at all times...not too shabby--or stressful--at all!).

## Importance of Units
Units, units, units! Always make units well-known in the help docs, GUIs, config files, other software program inputs, code comments, etc.

## Data File Format
CSV is not tied to Microsoft Office Suite
It can be opened in text files
Smaller file sizes
XLS has limit to number of rows
XLS is only 65,536 rows; XLSX is just over 1M (1,048,576)
Neither Excel format can fit more than a couple years of 5-min data
Need a programming language for that (e.g., Python, R, MATLAB, LabVIEW)

## Attention and Focus
NB: Some redundancy w/ other Getting Started files.

Promote the one computer-, one screen-, and one window-at-a-time approach for maintaining attention and focus. Keep Git synced--after each edit--to whatever branch is appropriate. See more in Getting Started with Git.

Full screen (F11) (incl. hide menu bar)
One screen
One window
Zero desktop
Zero GitHub (i.e., Zero GitHub Desktop, i.e., keep Git/GitHub synced)
Zero local(-only)
Zero inbox

## KISS
Embrace all things KISS: Keep It Simple, Stup!d!

## General Coding & Writing Principles
1. KISS
2. Less is more
3. Use Simple English (or Simple Whatever-language)

## Grammar
If/when you can't figure out if a word or phrase is the best one to use or not, consider if it's best to delete it altogether.

## When to Edit
Adding commentary is always good. However, when it comes to editing code, heed the following warning (i.e., take caution & tread lightly): If it ain't broke, don't fix it.

## Basic Git Repository Contents
NB: See Getting Started w/ Git.

## Development Environment Philosophy
Before doing anything (coding, cooking, ordering something online, taxes), set up your "dev environment"; namely, the development environment which contains all (/only) the necessary data and tools needed to complete the task. Then, when you have time to focus, complete the task in the dev environment, document and comment everything, close it out (both the task & the environment), archive and/or back up what's needed, and move on w/ life. Maintaining a dedicated dev environment for each significant home or work life task also makes it easier to transition into and out of that task (e.g., from another task or activity) whenever you find time to focus and spend on it; namely, transitioning into and out of the dev environment becomes equated with transitioning into and out of completing the task. (Obviously, in reality, to be exact about any of this is overkill--hopefully you get the pt!)

## End-of-code Snippet
Playful end-of-code snippet to inform that code, program, or script is finished (that it ran completely).
MATLAB:
% Shout-out to JHF
disp('Congrats. The program ran completely. Crack open an ice-cold beer.')
Python:
# Shout-out to JHF
print('Congrats. The program ran completely. Crack open an ice-cold beer.')

## "Kennythonic" Syntax Conventions
NB: Inspired by "Pythonic" syntax conventions
Capitalize acronyms esp. of proper nouns (unless informal)
Git repos: No CamelCase; lowercase only; dashes not underscores
Sub-folders w/in Git repos: Lowercase only w/ underscores
Variable names: PascalCase is O-K; so is camelCase (e.g., whatEver WorksFor youNyou, & You, & you2...just not 4you!)
In title string, capitalize words that are four (4) letters or more (credit to the APA).
Periods are not needed in code commentary (code needs perfect syntax in order to run properly; comments do not need perfect syntax in order to serve their intended purpose--namely, to help a developer or user understand what the code's doing; in fact, sometimes it's better to reduce punctuation & spacing in order to keep the codebase as simply & small as possible in computer memory).

## Common Data Filtration Logic
(Industry-agnostic; incidentally, as is the intention of most of Getting Started)
Various high- & low- pass filters
If any value in row is NaN, make whole row NaN
Longer:
If any (column-)value in row of columns is NaN, make whole (entire) row NaN

## Design of Mathematical Functions
Keep mathematical functions specific to the math equations. Format inputs to functions external to the functions.

## Project Management
In project execution, there is cost, quality, and time. Choose two (2), i.e., you cannot simultaneously have all three (3).

## Hypothesis
All programming languages effectively can do the same things, i.e., it's likely you can achieve the same end goals regardless of what language you choose. Some languages come w/ different functions than others. These built-in functions make certain tasks more convenient for the user (so the user doesn't have to write them from scratch). Choose the language for the built-in functions you think you will use.

## Programming
"Coding is basically just ifs and for loops."
Source: https://twitter.com/ID_AA_Carmack/status/1466934223831506951/
Paraphrased mine (long): Programming is just if statements & for loops plus a whole (heck of a) lot of (syntactic) frustration.
Paraphrased mine (short): Programming consists of 1% if statements & for loops and 99% frustration.
Paraphrased mine, w/ additions: Programming consists of For Loops, If Statements, linear algebra, logic, & language syntax.

## Best Indexing Variable Name
Use ii, jj, & kk. It's easier to find w/ Ctrl+f than i, j, & k.

## Most Basic Workflow for All Jobs, Tasks, & Work
Check out X, do what you have to do to X (make your change or whatever), commit change of X (into some sort of documented form/system), & check X back in. Done. Don't make things any more complex than they need to be. Going "above & beyond" is not getting the job done better than sticking to the most basic task & moving from one task to the next in this fashion.