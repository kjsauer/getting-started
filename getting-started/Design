# Getting Started: Code and Program Architecture, Design, and Philosophy Principles
Kenneth J. Sauer (kjsauer)

## String Inputs
Import all inputs as strings
Convert the data type only when needed
For example, for decimal truncation or use in numerical calculations (e.g., unit conversions)
Then convert back to string

## Rosetta Stone
Ideally every piece of code would have a data structure Rosetta Stone (RS)
Need cookie-cutter code to implement Rosetta Stone in standard way

## Functions
Functions and APIs are similar (receive inputs; send outputs)
Write functions to take inputs with SI units
Thereby not a question as to what the units are

## Software Design
Fundamentals: EXE + config.csv
EXE prompts user for path of config.csv
EXE needs to be able to find config.csv
config.csv has vertical columns like a database
config.csv can have multiple rows representing different sets of inputs
Design config.csv for SQL

## Good Practice
Unit tests
Rosetta Stones
config.csv files
.exe plus runtime files

## General Principles
99% planning (and perspiration); 1% execution (and more perspiration...and 0% genius throughout...)

##
Starting a project
Ideally work backwards
Start with end functionality
e.g., Some literal function like Box Plot
This will drive the necessary data structures
Make those data structures in Excel test data file
Implement in Python, MATLAB, R, etc.
If importing/exporting, target CSV database format

##
Start by finding the function you want
The function drives the data structure(s) aka data frame(s)

##
How to avoid messing up a series of user actions in a GUI?

## Concept
How does MS Outlook not mess up my email when I make a series of actions? e.g., Moving emails from one folder to another
Theory: Because it stores a time-ordered queue of every user action and gradually worked through the queue
Apply this concept (user action time series queue) in software (GUI) development

## Data Analysis
Work with clean example SQL or CSV databases when possible
Execute calculations in legible/readable code script (e.g., Python notebook)

## Tests to run to familiarize with new software language
Inf/0
NaN + NaN
5 + NaN
NaN/0

##
When you complete a project, zip all project files and save in project folder
Consider exporting .ipynb to .py as a secondary backup of the code

##
Code
--.ipynb
Data
--.csv
--.xls
--.xlsx
Metadata
--.txt
--.yml
--.xml
--.json

## Lessons Learned
Use Microsoft Excel template instead of Python script; copy/paste data into it. You may also use Excel as a GUI.

##
Package ALL help documentation and ALL examples (unit tests) and ALL unit test data into the repos; yes, the repo will become large, but everything will be in ONE folder that can be easily transferred and booted up and will be ready to rock.

##
Rule: Every input must be a config (or data) file. This way others can tweak the input config files and not the code. Write code so others can get started quickly. Provide unit test with software program, data, and metadata, and program help menu (if needed). Provide answers as well so the user knows if the program ran correctly.

##
Provide:
--_todo/Future Work
--Analysis Templates
--Code and Scripts
--Data
--Docs (incl. Help Menu)
--Lessons Learned
--Metadata
--Report Templates
--Unit Tests: Known inputs
--Unit Tests Results: Known outputs 
--Work Instructions

## _todo List
Always have a _todo List that is numbered.
1. [DONE] (hm) Make _todo list for home tasks.
2. [DONE] (wk) Make _todo list for work tasks.
3. (hm) Win the lottery, amass a fortune, and retire to an island getaway.
4. [DONE] Mark items as Done when completed.

## Unit Test Exercise Philosophy
Unit test: Known inputs/known outputs
Purpose(s):
So that an engineer can know someone/something is properly trained.
So that you can ensure an updated tool yields the same results.

## File Naming
Short yet descriptive filenames are best. Bear in mind Indexing and Search. How would you search for/find the file?

## General Computer Usage
Find ways to avoid using the mouse whenever possible.

## Work vs. Personal
Keep work projects separate from personal projects.
Same GitHub account is fine.
Work on different computers in different repos.
When engaging in industry for learning, etc., use personal email.
When representing a company in the engagement, use company email.

## Documentation
In all cases, package into one, single repository all of the necessary files required to reproduce an expected set of results (which is also contained in the repository). Consider this from the time of project onset.

## Standalone Application (EXE)
tbd.

## Build Auto-Image Detection Tool
Build training GUI.
Have algorithm make guess via artificial intelligence (AI) and machine learning (ML).
Have operator (human) correct guess.
This new human data is incorporated into AI/ML algorithm to improve it.
Calculate % accuracy each time; it should improve up to some high value, e.g., >97.5% (ideally higher).

## Timestamps
Use format YYYY-MM-DD hh:mm:ss

## Output File(s) Storage
Save into pwd\Ouptuts_timestamp,
where timestamp is updated each time.
See MATLAB Getting Started for example.

## Software Design
EXE + CFG.txt --> GUI EXE
GUI includes text field for path to raw input data files.

## Software Design
Docs
--General Intro and Data Needs
--Work Instructions
Tool
---README
---EXE (launches GUI)
---CFG.txt (replaces GUI)

##
Before doing any project, design the END product: The folder directory, the final results table, etc. Imagine the very end result (as far as you can go). Set up the empty architecture or template and then work towards populating it as fast as possible while skipping all the details (which usually end up being irrelevant anyway). A fully populated architecture (e.g., a folder with subfolders) can be zipped into one zip file that has everything needed for anyone to reproduce it at any later time as needed. This approach even goes for something like cooking a meal. Prepare the ingredients, dishes, condiments, etc. in advance. Fill and use them all as you go. (I'm not actually suggesting the latter; it's merely for the sake of metaphor).

## Always maintain four folders
_dev Project --personal, not shared
Project Eng Dev --shared
Project Training --shared
Project Training Results --shared

## NREL fancy site file
Site information .csv self-produces a map of its own location. This cellular-genetic-like approach of embedding within something the ingredients and algorithm to make itself is quite interesting/appealing/compelling from a coding perspective (as with a biological organism), e.g., a code script that saves itelf and everything it needs to produce a given set of results into a repository. If I recall correctly, I believe this general, philosophical concept relates to the PhD thesis of Stephen Wolfram (American-British computer scientist).

## Timely HackerNews Advice
Build tools around workflows, not workflows around tools.
<https://news.ycombinator.com/item?id=24244329>
(I only read the headline, and I agree with it.)

## Software Design Adjectives
Design software to be simple, isolated, encapsulated, and modular.

## A Lobster's Advice
Don't marry your design after the first date. (I might add: You may not want to marry your first partner, either.) Credit not mine: <https://lobste.rs/s/rvuyep/don_t_marry_your_design_after_first_date/>

## Software Documentation Hand-off Requirements
1. Software program
2. Getting Started
3. Help Menu
4. Functional specification (description of inputs nad outputs)
5. Testing specification (unit aka regression test)
6. Theory guide
7. Practice guide

## Reason to Code (vs. Spreadsheets, etc.)
Code does not lie; it intrinsically says what it does.

## Web App Design
Config (CFG) files into one format (e.g., .json).
Data files into another format (e.g., .csv).

## Handing off from Engineering to Operations
One single, executable file (EXE) with a graphical user interface (GUI) is ideal for a user, technician, or operator.
(Actually, web-deployed applications are ideal.)
Cannot require manual modification of data files.
Modification of config files is O-K.
Config (CFG) files can be replaced by the GUI.

## Key Files for Handoff from Engineering to Operations
Files needed for technician's/operator's machine:
1. Runtime and Runtime Update, if needed (e.g., MATLAB)
2. EXE of GUI (e.g., MATLAB, LabVIEW)
3. Downloaded data files of a given format and type in a given path.
4. Config CFG files in a given path.
The EXE generates an output folder in which to place output files.

## Design for EXE
An EXE can be run (called) w/ any language (e.g., Python, R, MATLAB, etc.).
e.g., Run EXE from Python:
$ run('C:\asdf1\asdf2.exe')

## Config CFG Files
Advantage of separate config file:
Save inputs for pre-processor for future.
A GUI replaces the need for CFG file.

## Technical Debt
Most technical debt is B.S. It's true! Make a numbered _todo list (prioritized for urgent *** and highly urgent !!!), and it is probably <200 items. The top priority of those (highlighted w/ both *** and !!!) is probably ten items at most at any given time. Technical debt is manageable w/ a good to-do list.
<https://lobste.rs/s/1gzlyu/most_technical_debt_is_just_bullshit/>

## Backing Up
Worry about saving and properly archiving the End. Don't worry about saving the Means to the End. It helps to save the Means, but don't sweat losing it (sh!t happens). If you focus on properly saving and archiving the End, then hopefully you won't lose that and will thus avoid any associated, larger regrets.