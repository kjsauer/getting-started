# Getting Started with Code and Software Program Architecture, Design, and Philosophy Principles
Kenneth J. Sauer (kjsauer on GitHub)

## Development Environments
Anaconda Python + Spyder + GitHub Desktop
MATLAB + GitHub Desktop
RStudio + GitHub Desktop

## String Inputs
Import all inputs as strings
Convert the data type only when needed
For example, for decimal truncation or use in numerical calculations (e.g., unit conversions)
Then convert back to string

## Rosetta Stone
Ideally every piece of code would have a data structure Rosetta Stone (RS)
Need cookie-cutter code to implement Rosetta Stone in standard way

## Functions
Functions and APIs are similar (receive inputs; send outputs)
Write functions to take inputs with SI units
Thereby not a question as to what the units are

## Software Design
Fundamentals: EXE + config.csv
EXE prompts user for path of config.csv
EXE needs to be able to find config.csv
config.csv has vertical columns like a database
config.csv can have multiple rows representing different sets of inputs
Design config.csv for SQL

## Good Practice
Unit tests
Rosetta Stones
config.csv files
.exe plus runtime files

## General Principles
99% planning (and perspiration); 1% execution (and more perspiration...and 0% genius throughout...)

## Starting a Project
Ideally work backwards
Start with end functionality
e.g., Some literal function like Box Plot
This will drive the necessary data structures
Make those data structures in Excel test data file
Implement in Python, MATLAB, R, etc.
If importing/exporting, target CSV database format

## See Functions Early On
Start by finding the function(s) you want
The function drives the data structure(s) aka data frame(s)

## GUI Question(s)
How to avoid messing up a series of user actions in a GUI?

## Concept
How does MS Outlook not mess up my email when I make a series of actions? e.g., Moving emails from one folder to another
Theory: Because it stores a time-ordered queue of every user action and gradually worked through the queue
Apply this concept (user action time series queue) in software (GUI) development

## Data Analysis
Work with clean example SQL or CSV databases when possible
Execute calculations in legible/readable code script (e.g., Python notebook)

## Programming Language Tests
Tests to run to familiarize with new software language:
Inf/0
NaN + NaN
5 + NaN
NaN/0

## Archive Projects
When you complete a project, zip all project files and save in project folder
Consider exporting .ipynb to .py as a secondary backup of the code

## File Types
Code
--.ipynb
Data
--.csv
--.xls
--.xlsx
Metadata
--.txt
--.yml
--.xml
--.json

## Lessons Learned
Use Microsoft Excel template instead of Python script; copy/paste data into it. You may also use Excel as a GUI.

## Repo Contents
Package ALL critical help documentation and ALL helpful getting started examples (unit tests) and ALL essential unit test data into the repos; yes, the repo will become large, but everything will be in ONE folder that can be easily transferred and booted up and will be ready to spin up & rock.

## Inputs Data and Metadata
Rule: Every input must be a config (or data) file. This way others can tweak the input config files and not the code. Write code so others can get started quickly. Provide unit test with software program, data, and metadata, and program help menu (if needed). Provide answers as well so the user knows if the program ran correctly.

## Empty Folder Template
Provide:
--_todo/Future Work/TODO
--Analysis Templates
--Code and Scripts
--Data
--Docs (incl. Help Menu)
--Lessons Learned
--Metadata
--Report Templates
--Unit Tests: Known inputs
--Unit Tests Results: Known outputs 
--Work Instructions

## _todo/TODO List
Always have a TODO List that is numbered.
1. [DONE] (hm) Make TODO list for home tasks.
2. [DONE] (wk) Make TODO list for work tasks.
3. (hm) Win the lottery, amass a fortune, and retire to an island getaway.
4. [DONE] Mark items as Done when completed.

## Unit Test Exercise Philosophy
Unit test: Known inputs/known outputs
Purpose(s):
So that an engineer can know someone/something is properly trained.
So that you can ensure an updated tool yields the same results.

## File Naming
Short yet descriptive filenames are best. Bear in mind Indexing and Search. How would you search for/find the file?

## General Computer Usage
Find ways to avoid using the mouse whenever possible.

## Work vs. Personal
Keep work projects separate from personal projects.
Same GitHub account is fine.
Work on different computers in different repos.
When engaging in industry for learning, etc., use personal email.
When representing a company in the engagement, use company email.

## Documentation
In all cases, package into one, single repository all of the necessary files required to reproduce an expected set of results (which is also contained in the repository). Consider this from the time of project onset.

## Standalone Application (EXE)
tbd.

## Build Auto-Image Detection Tool
Build training GUI.
Have algorithm make guess via artificial intelligence (AI) and machine learning (ML).
Have operator (human) correct guess.
This new human data is incorporated into AI/ML algorithm to improve it.
Calculate % accuracy each time; it should improve up to some high value, e.g., >97.5% (ideally higher).

## Timestamps
Use format YYYY-MM-DD hh:mm:ss

## Output File(s) Storage
Save into pwd\Ouptuts_timestamp,
where timestamp is updated each time.
See MATLAB Getting Started for example.

## Software Design
EXE + CFG.txt -> GUI EXE
GUI includes text field for path to raw input data files.

## Software Design
Docs
--General Intro and Data Needs
--Work Instructions
Tool
---README
---EXE (launches GUI)
---CFG.txt (replaces GUI)

## Start w/ Empty Results Structure
Before doing any project, design the END product: The folder directory, the final results table, etc. Imagine the very end result (as far as you can go). Set up the empty architecture or template and then work towards populating it as fast as possible while skipping all the details (which usually end up being irrelevant anyway). A fully populated architecture (e.g., a folder with subfolders) can be zipped into one zip file that has everything needed for anyone to reproduce it at any later time as needed. This approach even goes for something like cooking a meal. Prepare the ingredients, dishes, condiments, etc. in advance. Fill and use them all as you go. (I'm not actually suggesting the latter; it's merely for the sake of metaphor).

## Working Directories
Maintain four (4) folders:
_dev Project --personal, not shared
Project Eng Dev --shared
Project Training --shared
Project Training Results --shared

## NREL Fancy Site File
Site information .csv self-produces a map of its own location. This cellular-genetic-like approach of embedding within something the ingredients and algorithm to make itself is quite appealing/compelling/interesting from a coding perspective (as with a biological organism), e.g., a code script that saves itself and everything it needs to produce a given set of results into a repository. If I recall correctly, I believe this general, philosophical concept relates to the PhD thesis of Stephen Wolfram (American-British computer scientist).

## Timely HackerNews Advice
Build tools around workflows, not workflows around tools.
<https://news.ycombinator.com/item?id=24244329>
(I only read the headline, and I agree with it.)

## Software Design Adjectives
Design software to be simple, isolated, encapsulated, and modular.

## A Lobster's Advice
Don't marry your design after the first date.
Source: <https://lobste.rs/s/rvuyep/don_t_marry_your_design_after_first_date/>

## Software Documentation Hand-off Requirements
1. Software program
2. Getting Started
3. Help Menu
4. Functional specification (description of inputs nad outputs)
5. Testing specification (unit aka regression test)
6. Theory guide
7. Practice guide

## Reason to Code (vs. Spreadsheets, etc.)
Code does not lie; it intrinsically says what it does.

## Web App Design
Config (CFG) files into one format (e.g., .json).
Data files into another format (e.g., .csv).

## Handing off from Engineering to Operations
One single, executable file (EXE) with a graphical user interface (GUI) is ideal for a user, technician, or operator.
(Actually, web-deployed applications are ideal.)
Cannot require manual modification of data files.
Modification of config files is O-K.
Config (CFG) files can be replaced by the GUI.

## Key Files for Handoff from Engineering to Operations
Files needed for technician's/operator's machine:
1. Runtime and Runtime Update, if needed (e.g., MATLAB)
2. EXE of GUI (e.g., MATLAB, LabVIEW)
3. Downloaded data files of a given format and type in a given path.
4. Config CFG files in a given path.
The EXE generates an output folder in which to place output files.

## Design for EXE
An EXE can be run (called) w/ any language (e.g., Python, R, MATLAB, etc.).
e.g., Run EXE from Python:
$ run('C:\asdf1\asdf2.exe')

## Configuration Config CFG Files
Advantage of separate config file:
Save inputs for pre-processor for future.
A GUI replaces the need for CFG file.

## Technical Debt
Most technical debt is B.S. It's true! Make a numbered TODO list (prioritized for urgent *** and highly urgent !!!), and it is probably <200 items. The top priority of those (highlighted w/ both *** and !!!) is probably ten items at most at any given time. Technical debt is manageable w/ a good to-do list.
<https://lobste.rs/s/1gzlyu/most_technical_debt_is_just_bullshit/>

## Backing Up
Worry about saving and properly archiving the End. Don't worry about saving the Means to the End. It helps to save the Means, but don't sweat losing it (sh!t happens). If you focus on properly saving and archiving the End, then hopefully you won't lose that and will thus avoid any associated, larger regrets.

## Dev vs. Production
Maintain a _dev environment (e.g., source code) that compiles/deploys into the production environment (e.g., compiled standalone EXE application).

## _dev Workflow
Start by gathering/collecting essential user inputs via CFG.txt file. Then add option for GUI. The CFG file forces the minimum viable set of inputs; it provides a nice, clean data specification.

## _todo aka TODO aka to-do
Maintain two "HEAD MAIN", numbered TODO lists: One for work (wk) and one for home (hm). You'll be surprised that all the items you think you have going on only boils down to roughly 300 simultaneous, concurrent projects at once (300 for work and 300 for home; come on, 600 simultaneous projects ongoing at all times...not too shabby--or stressful--at all!).

## Importance of Units
Units, units, units! Always make units well-known in the help docs, GUIs, config files, other software program inputs, code comments, etc.

## Data File Format
CSV is not tied to Microsoft Office Suite
It can be opened in text files
Smaller file sizes
XLS has limit to number of rows
XLS is only like 65,536 rows; XLSX is just over 1M (1,048,576)
Neither Excel format can fit more than a couple years of 5-min data
Need a programming language for that (e.g., Python, R, MATLAB, LabVIEW).

## Attention and Focus
Promote the one computer-, one screen-, and one window-at-a-time approach for maintaining attention and focus.

## KISS
Embrace all things KISS: Keep It Simple, Stup!d!

## Basic Git Repo Contents
NB: Duplicated in Getting Started w/ Git.
repo-name folder\
--.gitattributes
--.gitignore
--AUTHORS
--COPYRIGHT
--README.md
--Subfolder of same repo-name\
--Subfolder of same repo-name\docs\
--TODO

## Development Environment Philosophy
Before doing anything (coding, cooking, ordering something online, taxes), set up your "dev environment"; namely, the development environment which contains all (/only) the necessary data and tools needed to complete the task. Then, when you have time to focus, complete the task in the dev environment, document and comment everything, close it out (both the task & the environment), archive and/or back up what's needed, and move on w/ life. Maintaining a dedicated dev environment for each significant home or work life task also makes it easier to transition into and out of that task (e.g., from another task or activity) whenever you find time to focus and spend on it; namely, transitioning into and out of the dev environment becomes equated with transitioning into and out of completing the task.